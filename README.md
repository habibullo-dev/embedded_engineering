# STM32F767ZI Interrupt-Driven LED Sequence Controller

A professional embedded systems project demonstrating interrupt-driven GPIO control, NVIC management, and event-driven programming on the STM32F767ZI microcontroller.

## üéØ Project Overview

This project implements an interrupt-driven LED sequence controller using the three onboard LEDs of the NUCLEO-F767ZI development board. The system demonstrates advanced embedded programming concepts including GPIO interrupts, ISR design, and efficient event-driven architecture.

### üé¨ Live Demonstration

Watch the interrupt-driven LED controller in action with immediate button response:

![LED Sequence Demo](./demonstration/led_hal_interrupt.gif)

*Press the blue user button to start the sequence: Green ‚Üí Green+Blue ‚Üí All LEDs ‚Üí Blue+Red ‚Üí Red ‚Üí Off. Button response is immediate regardless of main loop timing.*

### Key Learning Objectives

This project advances embedded systems development skills with interrupt-driven programming concepts:

- **GPIO Interrupt Programming**: Hardware-driven event detection with EXTI configuration
- **Interrupt Service Routine (ISR) Design**: Fast, efficient interrupt handlers following best practices
- **NVIC Management**: Interrupt priority configuration and nested interrupt handling
- **Event-Driven Architecture**: Responsive systems that react immediately to external events
- **Safe Inter-Context Communication**: Proper data sharing between interrupt and main contexts
- **Volatile Variable Usage**: Understanding compiler optimization and interrupt-safe programming

## üîß Hardware Requirements

### Development Board
- **NUCLEO-F767ZI** development board with STM32F767ZI microcontroller
- Built-in ST-Link programmer/debugger
- USB cable for power and programming

### Hardware Configuration
The project uses the onboard peripherals of the NUCLEO-F767ZI board:

- **Green LED (LD1)**: Connected to GPIO pin PB0
- **Blue LED (LD2)**: Connected to GPIO pin PB7  
- **Red LED (LD3)**: Connected to GPIO pin PB14
- **User Button**: Connected to GPIO pin PC13 (active LOW with external pull-up)
- **Interrupt Line**: PC13 mapped to EXTI15_10 interrupt vector

No external components required - all functionality uses onboard hardware.

## üíª Software Requirements

### Development Environment
- **STM32CubeIDE** version 1.8 or later (recommended)
- **STM32CubeMX** for hardware configuration (integrated with CubeIDE)
- **STM32F7 HAL Library** (automatically managed by CubeIDE)

### Supported Operating Systems
- Windows 10/11
- macOS 10.15 or later
- Ubuntu 18.04 LTS or later

## üèóÔ∏è Project Architecture

### Interrupt-Driven Design

The system uses event-driven architecture with two execution contexts:

- **Main Context**: LED sequence management, background processing
- **Interrupt Context**: Immediate button event detection and signaling

### Code Organization

```
Core/
‚îú‚îÄ‚îÄ Src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c              # Main application and interrupt handlers
‚îÇ   ‚îú‚îÄ‚îÄ gpio.c              # GPIO initialization (generated by CubeMX)
‚îÇ   ‚îî‚îÄ‚îÄ system_stm32f7xx.c  # System configuration
‚îú‚îÄ‚îÄ Inc/
‚îÇ   ‚îú‚îÄ‚îÄ main.h              # Pin definitions and function prototypes
‚îÇ   ‚îú‚îÄ‚îÄ gpio.h              # GPIO function declarations
‚îÇ   ‚îî‚îÄ‚îÄ stm32f7xx_hal_conf.h # HAL library configuration
```

### Interrupt Chain

The interrupt handling follows this execution chain:

1. **Hardware Event**: Button press generates EXTI13 interrupt
2. **Vector Handler**: `EXTI15_10_IRQHandler()` called by processor
3. **HAL Processing**: `HAL_GPIO_EXTI_IRQHandler()` clears interrupt flags
4. **User Callback**: `HAL_GPIO_EXTI_Callback()` sets event flag
5. **Main Processing**: Main loop processes event when convenient

### State Machine Design

Identical eight-state LED sequence as polling version:

- **LED_SEQ_IDLE**: System ready, waiting for interrupt
- **LED_SEQ_GREEN_ON**: Green LED activated
- **LED_SEQ_BLUE_ON**: Blue LED added
- **LED_SEQ_RED_ON**: All three LEDs active
- **LED_SEQ_PAUSE_ON**: Brief pause with all LEDs on
- **LED_SEQ_GREEN_OFF**: Begin shutdown, green LED off
- **LED_SEQ_BLUE_OFF**: Blue LED off
- **LED_SEQ_RED_OFF**: Red LED off
- **LED_SEQ_COMPLETE**: Sequence finished, return to idle

## ‚öôÔ∏è Configuration Options

### Interrupt Configuration

Key interrupt parameters:

```c
// GPIO interrupt mode
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  // Interrupt on button press

// NVIC priority configuration
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);  // Highest priority
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);          // Enable interrupt
```

### Timing Constants

```c
#define DEBOUNCE_TIME_MS        50    // Button debounce period
#define LED_TRANSITION_DELAY_MS 500   // Time between sequence steps
#define MAIN_LOOP_DELAY_MS      10    // Main loop interval
```

### Volatile Communication Structure

```c
typedef struct {
    volatile uint32_t last_interrupt_time;    // ISR timestamp
    volatile uint8_t button_event_pending;    // Event flag
} interrupt_comm_t;
```

## üîÑ Polling vs Interrupt Comparison

| Aspect | Polling Version | Interrupt Version |
|--------|----------------|-------------------|
| **Response Time** | 0-20ms (variable) | <1ms (immediate) |
| **CPU Efficiency** | Continuous checking | Event-driven only |
| **Button Detection** | Can miss brief presses | Never misses events |
| **Code Complexity** | Single context | Dual context (main + ISR) |
| **Scalability** | Poor with multiple inputs | Excellent scaling |
| **Power Consumption** | Higher (continuous polling) | Lower (sleep possible) |

## üß™ Testing and Validation

### Functional Testing

1. **Immediate Response**: Button press during any sequence state stops immediately
2. **No Missed Events**: Rapid button presses all detected
3. **Consistent Timing**: LED sequence timing unaffected by button events
4. **Interrupt Latency**: Measure response time with oscilloscope (<1ms)

### Performance Characteristics

- **Button Response**: <1ms interrupt latency
- **Debounce Period**: 50ms software debouncing
- **Sequence Timing**: 500ms per LED transition
- **Power Efficiency**: >99% CPU idle time for button monitoring

## üéØ Next Steps

This interrupt foundation prepares for advanced topics:

- **Timer Interrupts**: Precise timing with hardware timers
- **Communication Protocols**: UART, SPI, I2C interrupt-driven operation
- **DMA Integration**: Interrupt-driven data transfer
- **FreeRTOS**: Task synchronization with interrupt events
