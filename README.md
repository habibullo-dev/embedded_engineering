# STM32F767ZI LED Sequence Controller

A professional embedded systems project demonstrating HAL-based GPIO control, state machine implementation, and non-blocking timing techniques on the STM32F767ZI microcontroller.

## üéØ Project Overview

This project implements a sequential LED controller that creates an engaging light show using the three onboard LEDs of the NUCLEO-F767ZI development board. The system demonstrates fundamental embedded programming concepts including button debouncing, state machine design, and responsive user interface implementation.

### üé¨ Live Demonstration

Watch the LED sequence controller in action! The demonstration shows the complete sequence cycle and interactive button control:

![LED Sequence Demo](./demonstration/led_sequence_demo.gif)

*Press the blue user button to start the sequence: Green ‚Üí Green+Blue ‚Üí All LEDs ‚Üí Blue+Red ‚Üí Red ‚Üí Off. Press the button during execution to immediately stop the sequence.*

### Key Learning Objectives

This project serves as a comprehensive introduction to professional embedded systems development, covering essential concepts that form the foundation for more advanced embedded programming:

- **HAL-based GPIO Programming**: Direct use of STM32 Hardware Abstraction Layer functions without BSP dependencies
- **State Machine Implementation**: Finite state machine design for managing complex sequential behaviors
- **Non-blocking Timing**: Creating time-based behaviors that maintain system responsiveness
- **Button Debouncing**: Robust input handling that eliminates mechanical switch noise
- **Hardware Abstraction**: Proper use of symbolic names and portable code design principles

## üîß Hardware Requirements

### Development Board
- **NUCLEO-F767ZI** development board with STM32F767ZI microcontroller
- Built-in ST-Link programmer/debugger
- USB cable for power and programming

### Hardware Configuration
The project uses the onboard peripherals of the NUCLEO-F767ZI board:

- **Green LED (LD1)**: Connected to GPIO pin PB0
- **Blue LED (LD2)**: Connected to GPIO pin PB7  
- **Red LED (LD3)**: Connected to GPIO pin PB14
- **User Button**: Connected to GPIO pin PC13 (active LOW with external pull-up)

No external components or wiring are required, making this project ideal for learning fundamental concepts without hardware complexity.

## üíª Software Requirements

### Development Environment
- **STM32CubeIDE** version 1.8 or later (recommended)
- **STM32CubeMX** for hardware configuration (integrated with CubeIDE)
- **STM32F7 HAL Library** (automatically managed by CubeIDE)

### Supported Operating Systems
- Windows 10/11
- macOS 10.15 or later
- Ubuntu 18.04 LTS or later

## üèóÔ∏è Project Architecture

### Code Organization

The project follows professional embedded systems development practices with clear separation of concerns:

```
Core/
‚îú‚îÄ‚îÄ Src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c              # Main application logic and state machine
‚îÇ   ‚îú‚îÄ‚îÄ gpio.c              # GPIO initialization (generated by CubeMX)
‚îÇ   ‚îî‚îÄ‚îÄ system_stm32f7xx.c  # System configuration
‚îú‚îÄ‚îÄ Inc/
‚îÇ   ‚îú‚îÄ‚îÄ main.h              # Pin definitions and function prototypes
‚îÇ   ‚îú‚îÄ‚îÄ gpio.h              # GPIO function declarations
‚îÇ   ‚îî‚îÄ‚îÄ stm32f7xx_hal_conf.h # HAL library configuration
```

### State Machine Design

The LED sequence controller implements a finite state machine with eight distinct states:

- **LED_SEQ_IDLE**: System ready, waiting for user interaction
- **LED_SEQ_GREEN_ON**: Green LED activated, beginning sequence
- **LED_SEQ_BLUE_ON**: Blue LED added to active LEDs
- **LED_SEQ_RED_ON**: All three LEDs now active
- **LED_SEQ_PAUSE_ON**: Brief pause with all LEDs illuminated
- **LED_SEQ_GREEN_OFF**: Begin shutdown sequence, green LED deactivated
- **LED_SEQ_BLUE_OFF**: Blue LED deactivated, only red remaining
- **LED_SEQ_RED_OFF**: Final LED deactivated
- **LED_SEQ_COMPLETE**: Sequence finished, return to idle state

### Timing Implementation

The system uses non-blocking timing techniques that maintain responsiveness while creating precise sequence timing. The implementation relies on `HAL_GetTick()` for millisecond-resolution timing without blocking the main program flow.

## ‚öôÔ∏è Configuration Options

### Timing Adjustments

Several timing constants can be modified to customize system behavior:

```c
#define DEBOUNCE_TIME_MS        50    // Button debounce period
#define LED_TRANSITION_DELAY_MS 500   // Time between sequence steps
#define MAIN_LOOP_DELAY_MS      10    // Main loop polling interval
```

### Hardware Customization

To adapt this code for different hardware configurations, modify the pin definitions in `main.h`:

```c
#define LD1_Pin GPIO_PIN_0          // Green LED pin
#define LD1_GPIO_Port GPIOB         // Green LED port
// Additional pin definitions...
```

## üß™ Testing and Validation

### Functional Testing

Verify correct operation by testing these scenarios:

1. **Power-On Behavior**: Confirm all LEDs start in OFF state
2. **Sequence Initiation**: Verify button press starts LED sequence correctly
3. **Sequence Progression**: Confirm LEDs activate in correct order with proper timing
4. **Sequence Completion**: Verify LEDs deactivate in reverse order
5. **Interactive Control**: Test immediate sequence termination via button press
6. **Button Responsiveness**: Confirm button responds correctly during sequence execution